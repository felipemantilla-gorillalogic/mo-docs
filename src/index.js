const core = require('@actions/core');
const github = require('@actions/github');
const Anthropic = require('@anthropic-ai/sdk');
const fs = require('fs').promises;
const path = require('path');

/**
 * Generates a prompt for AI to add documentation to the given code.
 * @param {string} fileContent - The content of the file to be documented.
 * @param {string} fileName - The name of the file.
 * @returns {string} The generated prompt for the AI.
 */
const generateDocPrompt = (fileContent, fileName) => {
  const fileExtension = path.extname(fileName).toLowerCase();
  let docType;

  if (['.js', '.ts', '.jsx', '.tsx'].includes(fileExtension)) {
    docType = 'JSDoc';
  } else if (['.py'].includes(fileExtension)) {
    docType = 'PyDoc';
  } else {
    docType = 'appropriate documentation style';
  }

  return `
    Please add ${docType} comments to the following code. Focus on adding documentation for functions, classes, and important variables. Do not modify the existing code, only add comments. Here's the code:

    ${fileContent}

    1. Provide the updated code with added documentation comments.
    2. Make sure to add comments for functions, classes, and important variables.
    3. Do not modify the existing code, only add comments.
    4. Return the updated code as a string.
    5. Only return the file content
  `;
};

/**
 * Validates the AI-generated content against the original content.
 * @param {string} originalContent - The original file content.
 * @param {string} aiGeneratedContent - The content generated by the AI.
 * @returns {boolean} True if the AI-generated content is valid, false otherwise.
 */
const validateAIContent = (originalContent, aiGeneratedContent) => {
  // Remove all comments and whitespace from both contents
  const cleanOriginal = originalContent.replace(/\/\*[\s\S]*?\*\/|\/\/.*/g, '').replace(/\s/g, '');
  const cleanAIGenerated = aiGeneratedContent.replace(/\/\*[\s\S]*?\*\/|\/\/.*/g, '').replace(/\s/g, '');

  // Compare the cleaned contents
  return cleanOriginal === cleanAIGenerated;
};

/**
 * Main function to run the GitHub Action.
 */
const main = async () => {
  try {
    // Auth with GitHub
    const token = core.getInput('github-token', { required: true });
    const octokit = github.getOctokit(token);

    // Auth with Anthropic
    const anthropicApiKey = core.getInput('anthropic-api-key', { required: true });
    const anthropic = new Anthropic({
      apiKey: anthropicApiKey,
    });

    // Getting PR data
    const requiredLabel = core.getInput('trigger-label', { required: true });
    const context = github.context;
    const { owner, repo } = context.repo;
    const pull_number = context.payload.pull_request ? context.payload.pull_request.number : context.payload.issue.number;

    core.info("Fetching PR details...");
    const { data: pullRequest } = await octokit.rest.pulls.get({
      owner,
      repo,
      pull_number,
    });

    // Check if the required label is present
    const isRequiredLabelPresent = pullRequest.labels.some(
      (label) => label.name === requiredLabel
    );

    if (!isRequiredLabelPresent) {
      core.info(`Required label ${requiredLabel} not present. Skipping documentation update.`);
      return;
    }

    if (pullRequest.state === 'closed' || pullRequest.locked) {
      throw new Error('Invalid event payload');
    }

    const { data: changedFiles } = await octokit.rest.pulls.listFiles({
      owner,
      repo,
      pull_number,
    });

    for (const file of changedFiles) {
      if (file.status !== 'modified' && file.status !== 'added') {
        continue;
      }

      try {
        // Fetch file content
        const fileContent = await octokit.rest.repos.getContent({
          owner,
          repo,
          path: file.filename,
          ref: pullRequest.head.sha,
        });

        const decodedContent = Buffer.from(fileContent.data.content, 'base64').toString('utf-8');

        // Generate documentation using Claude
        const prompt = generateDocPrompt(decodedContent, file.filename);
        const message = await anthropic.messages.create({
          model: "claude-3-5-sonnet-20240620",
          max_tokens: 2048,
          messages: [{ role: "user", content: prompt }],
        });

        const updatedContent = message.content[0].text;

        // Validate AI-generated content
        if (!validateAIContent(decodedContent, updatedContent)) {
          throw new Error(`AI-generated content for ${file.filename} is invalid. Skipping update.`);
        }

        // Update the file with new content
        await octokit.rest.repos.createOrUpdateFileContents({
          owner,
          repo,
          path: file.filename,
          message: `Add documentation comments to ${file.filename}`,
          content: Buffer.from(updatedContent).toString('base64'),
          sha: fileContent.data.sha,
          branch: pullRequest.head.ref,
        });

        core.info(`Updated ${file.filename} with documentation comments`);
      } catch (e) {
        core.warning(`Failed to update ${file.filename}: ${e.message}`);
      }
    }

    // Remove label
    await octokit.rest.issues.removeLabel({
      owner,
      repo,
      issue_number: pull_number,
      name: requiredLabel,
    }).catch(e => {
      core.warning(`Failed to remove label: ${e.message}`);
    });

    core.info('Documentation update completed successfully');
  } catch (err) {
    core.setFailed(`Action failed: ${err.message}`);
  }
};

main();